Upoznavanje sa alatima Moose i SonarQ.
TRazenje adekvatnog projekta za analizu.

Projekat sa kojim zapocinjem analizu je poprilicno velik, ima 1120 klasa, 3512 atributa, 15282 metode... 
Projekat je parsiran u .mse fajl pomocu VerveineJ pasera i importovan u Moose.
POmocu Queries Browser-a mozemo kreirati razlicite upite i vrsiti selekciju za dalju analizu.

Kada u upitu selektujemo svih 1120 klasa i otvorimo arhitectural map mozemo dodati veze nasledjivanja i tako analizirati dubinu nasedjivanja medju klasama. 
Vidimo da je klasa BaseContextSensitiveText klasa koja se najvise nasledjuje, odnosno druge klase koriste njene metode ili ih prosiruju. 
Kada malo bolje pogledamo koje klase nasledjuju klasu BaseContextSensitiveText vidimo da su to sve Test klase.
Jos neke klase koje se najvise nasledjuju: BaseOpenmrsObject, BaseOpenmrsService, BaseChangableOpenmrsMetadata.
Kada dodamo podupit da selektujemo sve Test klase mozemo videti da preko 50% Test klasa nasledjuje klasu BaseContextSensitiveText.

Kada upitom selektujemo pakete mozemo videti da je sav kod organizovan u dva glavna paketa liquibase i org. Iz slike mozemo da vidimo hijerarhiju nasledjivanja medju paketima.
Paket liquibase nasledjuje elemente paketa org, odnosno paket liquibase.ext.change nasledjuje paket org.openmrs koji je najveci paket u projektu. Mozemo videti da dalje taj paket nasledjuje klasu DispatcherServlet iz paketa org.springframework.web.servlet.

U Butterfly map mozemo videti strukturu jedne klase, sa leve strane vidimo sve tipove koji koriste zadatu klasu a sa leve sta se sve nalazi u toj klasi (ko zavisi od nje i od koga ona zavisi).
Projekat koji sam pocela da analiziram izgleda nije dobro parsiran i cini mi se da ce biti prevelik za analizu. 
------------------------------------------------------------------------------------------------------------------------------------------------
za pocetak uocavam da je Moose alat koji se fokusira na analizu slo≈æenosti klasa, metoda, broj metoda po klasi, broj linija po metodi, generalno analizu softverske arhitekture, dok SonarQube ima fokus na statickoj analzi, slozenost koda, duplikacije, broj linija, f-ja, klasa, pokrivenost testovima itd.

Zapocinjem analizu sa drugim projektom koji deluje da je bolje parsiran i malo je manji od prethodnog.

Moose pokazuje da projekat ima 12 paketa, upitom selektujem sve pakete i prikazem ih u Architectural map mogu da vidim da je glavni paket org u njemu senalazi paket joda u kom se nalaze paketi example i time. Paket example takodje ima paket time.
Sto se nasledjivanja tice koje mozemo videti selektovanjem FamixTInheritance veze, nema nasledjivanja izmedju paketa org, joda, example i example.time, ali unutar samog paketa time ima dosta veza nasledjivanja.
Kako bi se fokusirala iskljucivo na paket time, dodajem child query koji izdvaja samo taj paket po nazivu. Iz slike mozemo da vidimo da je najvise strelica upereno na paket base, sto znaci da velik broj elemenata nasledjuje ovaj paket, takodje jos jedan paket koji ima upecatljiv broj veza nasledjivanja je field.
Sa druge strane, sonarQube pokazuje malo drugaciju strukturu paketa, glavni folder je src, a u njemu se nalaze changes, example/org/joda/example/time, main, site, test/java/org/joda/time.

Sto se klasa tice, Moose prepoznaje 528 razlicitih klasa, dok SonarQube broji 478 klasa. U Moose alatu mozemo videti veze nasledjivanja medju klasama, dok sonarQube ne nudi tu opciju.
U sonarQube mozemo da vidimo da se u paketu example/org/joda/example/time nalazi 21 klasa, dok ekvivalentan paket org/joda/example/time u Moose ima svega 5 klasa, od cega se unutar klase DateTimeBrowser nalazi 13 klasa, isto to pokazuje i Moose. 
Ova klasa ukazuje na visok nivo slozenosti, teska je za razumevanje, odrzavanje i testiranje, pre svega narusava Single Responsibility Principle gde bi svaka klasa trebalo da ima jednu jasno definisanu odgovornost, a i ponovna upotreba koda je znatno otezana.
Dalje, 243 klase se nalaze unuatar paketa main/java/org/joda/time sto je ekvivalentno org/joda/time iz Moose analize gde se rezultati relativno poklapaju. Daljom analizom vidim da i klasa DateTimeFormaterBuilder ima 15 klasa. 
Paket test/java/org/joda/time ima 214 klasa, u kom sve klase deluju dobro struktuirane i sadrze svega nekoliko klasa u sebi, u Moose alatu sve ove klase obuhvacene su unutar org/joda/time paketa.
U Moose alatu mozemo detaljno da analiziramo klasu DateTimeBrowser unutar Butterfly map i vidimo da klasu ne koristi ni jedan objekat, a da se u njoj nalazi jako velik broj klasa ,metoda itd. Sa druge strane pomenuta klasa DateTimeFormatterBuilder ima jako puno elemenata i sa jedne i sa druge strane. Ovakav vizuelni prikaz ne moze se videti u sonarQube.
